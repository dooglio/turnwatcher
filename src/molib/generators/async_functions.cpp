/////////////////////////////////////////////////////////////////////////////////
//
//	File	 :	generators/async_functions.c++
//	Object	 :	Replace async functions in a .async file into the necessary header and .c++
//	Copyright:	Copyright (c) 2005-2008 Made to Order Software Corp.
//			All Rights Reserved.
//
//	This software and its associated documentation contains
//	proprietary, confidential and trade secret information
//	of Made to Order Software Corp. and except as provided by
//	written agreement with Made to Order Software Corp.
//
//	a) no part may be disclosed, distributed, reproduced,
//	   transmitted, transcribed, stored in a retrieval system,
//	   adapted or translated in any form or by any means
//	   electronic, mechanical, magnetic, optical, chemical,
//	   manual or otherwise,
//
//	and
//
//	b) the recipient is not entitled to discover through reverse
//	   engineering or reverse compiling or other such techniques
//	   or processes the trade secrets contained therein or in the
//	   documentation.
//

#include	<stdlib.h>
#include	<stdio.h>
//#include	<unistd.h>
#include	<string.h>
#include	<errno.h>
#include	<ctype.h>

#ifdef _MSC_VER
#pragma warning(disable: 4996)
#endif


bool g_force;
char *g_output = const_cast<char*>("./");
int g_errcnt;
const char g_auto_generated[] = "/* this file was auto-generated by the async_functions tool */";


class str_keeper
{
public:
	str_keeper( char *str ) : f_str(str) {}
	~str_keeper() { delete f_str; }
private:
	char * f_str;
};

void setoutput(const char *output)
{
	size_t o;

	// can't accept empty output path
	if(output == 0 || *output == '\0') {
		output = "./";
	}

	// check whether we need to add '/' at the end
	o = strlen(output);
	if(output[o - 1] != '/') {
		g_output = new char[o + 2];
		memcpy(g_output, output, o);
		g_output[o] = '/';
		g_output[o + 1] = '\0';
	}
	else {
		// perfect, save it as is
		g_output = (char *) output;
	}
}

FILE *open_output(const char *filename, long len, const char *ext)
{
	FILE	*f;
	size_t	l, o;
	char	buf[256];

	l = strlen(ext);
	o = strlen(g_output);	// already include '/' at the end
	//
	char *name = new char[o + len + l + 1];
	str_keeper sk( name );
	memcpy(name, g_output, o);
	memcpy(name + o, filename, len);
	memcpy(name + o + len, ext, l);
	name[o + len + l] = '\0';
	if(!g_force) {
		f = fopen(name, "rb");
		if(f != 0) {
			// the file already exists, let's make sure we're not
			// overwriting some random user file
			l = fread(buf, 1, sizeof(g_auto_generated) - 1, f);
			fclose(f);
			if(l != sizeof(g_auto_generated) - 1
			|| memcmp(buf, g_auto_generated, sizeof(g_auto_generated) - 1) != 0) {
				fprintf(stderr, "%s:1: error: cannot overwrite file; it does not look like an auto-generated file\n", name);
				g_errcnt++;
				return 0;
			}
		}
	}

	f = fopen(name, "wb");
	if(f == 0) {
		fprintf(stderr, "%s:0: error: cannot open file\n", name);
		g_errcnt++;
	}
	else {
		// always write that at the very beginning
		l = fprintf(f, "%s\n", g_auto_generated);
		// TODO: working under Mingw?! fprintf() does not return count, right?
		if(l < sizeof(g_auto_generated)) {
			fclose(f);
			remove(name);
			fprintf(stderr, "%s:1: error: cannot write into output file\n", name);
			g_errcnt++;
			f = 0;
		}
		else {
			fflush(f);
		}
	}

	return f;
}


char *read_input(const char *filename, FILE *f)
{
	size_t size, sz;
	char *buf;
	int e;
	fseek(f, 0, SEEK_END);
	size = ftell(f);
	fseek(f, 0, SEEK_SET);
	buf = new char[size + 1];
	buf[size] = '\0';
	sz = fread(buf, 1, size, f);
	if(sz != size) {
		g_errcnt++;
		e = errno;
		fprintf(stderr, "%s:1: error: ", filename);
		errno = e;
		perror(0);
		delete [] buf;
		return 0;
	}
	return buf;
}

class Param
{
public:
	Param(void)
	{
		f_next = 0;
		f_type = 0;
		f_ftype = 0;
		f_fullname = 0;
		f_name = 0;
		f_default_value = 0;
		f_function = false;
	}

	~Param()
	{
		delete f_next;
		delete [] f_type;
		delete [] f_ftype;
		delete [] f_fullname;
		// f_name is a pointer within f_fullname
		delete [] f_default_value;
	}

	void AppendType(const char *s, int l)
	{
		char *d;
		// we could assume that isn't possible...
		while(l > 0 && isspace(*s)) {
			s++;
			l--;
		}
		if(f_type == 0) {
			f_type = new char[l + 1];
			d = f_type;
		}
		else {
			size_t sz = strlen(f_type);
			char *n = new char[sz + l + 2];
			memcpy(n, f_type, sz);
			n[sz] = ' ';	// separated by a space
			delete [] f_type;
			f_type = n;
			d = f_type + sz + 1;
		}
		while(l > 0) {
			l--;
			// transform all spaces in ' '
			if(*s == '\n' || isspace(*s)) {
				*d = ' ';
			}
			else {
				*d = *s;
			}
			// avoid two spaces one after another
			if(d <= f_type || d[0] != ' ' || d[-1] != ' ') {
				d++;
			}
			s++;
		}
		// remove spaces from the end
		while(d > f_type && d[-1] == ' ') {
			d--;
		}
		*d = '\0';
	}

	void SetDefaultValue(const char *s, long l)
	{
		delete f_default_value;
		f_default_value = new char[l + 1];
		memcpy(f_default_value, s, l);
		f_default_value[l] = '\0';
	}

	void DefineName(void)
	{
		if(f_type == 0) {
			return;
		}
		if(*f_type == '\0') {
			return;
		}
		int l;
		bool cpp = false;
		const char *s, *n;
		s = f_type;
		if(f_function) {
			while(*s != '(' && *s != '\0') {
				s++;
			}
			// this shouldn't happen since f_function is set
			// to true whenever '(' is found in the type
			if(*s != '(') {
				return;
			}
			do {
				s++;
			} while(*s == '*' || *s == ' ');
			// a C++ function name can include a class/namespace:
			//	void (moBase::*func)()
			n = s;
			while((*s >= 'a' && *s <= 'z')
			   || (*s >= 'A' && *s <= 'Z')
			   || (*s >= '0' && *s <= '9')
			   || *s == '_' || *s == ':' || *s == '*') {
				if(*s == '*') {
					cpp = true;
				}
				s++;
			}
		}
		else {
			// the name is the last word in this case
			n = s;
			while(*s != '\0') {
				if(isspace(*s)) {
					n = s + 1;
				}
				s++;
			}
		}
		delete [] f_fullname;
		l = static_cast<int>(s - n);
		f_fullname = new char[l + 1];
		memcpy(f_fullname, n, l);
		f_fullname[l] = '\0';
		if(cpp) {
			f_name = strrchr(f_fullname, '*') + 1;
		}
		else {
			f_name = f_fullname;
		}
	}

	const char *FType(void)
	{
		if(f_ftype != 0) {
			return f_ftype;
		}
		if(f_type == 0) {
			return "";
		}
		if(*f_type == '\0') {
			return "";
		}
		size_t l = strlen(f_type);
		delete [] f_ftype;
		f_ftype = new char[l + 3];
		f_ftype[l + 2] = '\0';
		const char *s = strrchr(f_type, '*');
		if(f_function && s != 0) {
			s++;
			while(*s == ' ') {
				s++;
			}
			int p = static_cast<int>(s - f_type);
			memcpy(f_ftype, f_type, p);
			f_ftype[p] = 'f';
			f_ftype[p + 1] = '_';
			memcpy(f_ftype + p + 2, s, l - p);
		}
		else {
			const char *s = strrchr(f_type, ' ');
			if(s == 0) {
				s = f_type;
			}
			else {
				s++;
			}
			int p = static_cast<int>(s - f_type);
			memcpy(f_ftype, f_type, p);
			f_ftype[p] = 'f';
			f_ftype[p + 1] = '_';
			strcpy(f_ftype + p + 2, s);
		}

		return f_ftype;
	}

	static int mystrcmp(const char *a, const char *b)
	{
		if(a == 0) {
			if(b == 0) {
				return 0;
			}
			if(*b == '\0') {
				return 0;
			}
			return -1;
		}
		if(b == 0) {
			if(*a == '\0') {
				return 0;
			}
			return 1;
		}
		return strcmp(a, b);
	}

	bool operator == (const Param& p) const
	{
		return mystrcmp(f_fullname, p.f_fullname) == 0
		    // f_name is part of fullname -- already compared
		    && mystrcmp(f_type, p.f_type) == 0
		    // f_ftype is part of fullname -- already compared
		    && mystrcmp(f_default_value, p.f_default_value) == 0
		    && f_function == p.f_function;
	}

	Param *f_next;
	char *f_fullname;
	char *f_name;
	char *f_type;
	char *f_ftype;
	char *f_default_value;
	bool f_function;
};


class Lex;
class Dynamic
{
public:
	class Func {
	public:
		Func(Func *next, const char *name)
		{
			f_next = next;
			size_t l = strlen(name) + 1;
			f_name = new char[l];
			memcpy(f_name, name, l);
		}
		~Func()
		{
			delete f_next;
			delete [] f_name;
		}
		const char * GetName(void) const
		{
			return f_name;
		}
		Func *Next(void) { return f_next; }
	private:
		Func *f_next;
		char *f_name;
	};

	Dynamic(Dynamic *dynamic, long line, Param *p, const char *name)
	{
#if 0
		// we sort the names alphabetically
		// NOTE: this is not necessary because we're using
		// mo_name_t for the 'switch' and these won't be in
		// the same order as the strings!
		Dynamic *n = f_next;

		p = n;
		if(n != 0) {
			n = n->f_next;
			if(n == 0) {
				if(strcmp(name, p->f_name) < 0) {
					n = p;
					p = 0;
					break;
				}
			}
			else {
				while(n != 0) {
					if(strcmp(name, n->f_name) < 0) {
						break;
					}
					p = n;
					n = n->f_next;
				}
			}
		}
		if(p == 0) {
			dynamic = this;
			f_next = n;
		}
		else {
			f_next = p->f_next;
			p->f_next = this;
		}
#else
		f_next = dynamic;
#endif
		f_line = line;
		f_params = p;
		size_t l = strlen(name) + 1;
		f_name = new char[l];
		memcpy(f_name, name, l);
		f_func_count = 0;
		f_funcs = 0;
	}
	~Dynamic()
	{
		delete f_next;
		delete [] f_name;
		delete f_params;
		delete f_funcs;
	}
	const char * GetName(void) const
	{
		return f_name;
	}
	bool CheckParams(Param *p)
	{
		// we MUST have exactly the same parameters
		// whenever two functions use the dynamic keyword
		Param *q = f_params;
		while(p != 0 && q != 0) {
			if(!(*p == *q)) {
				// incompatible parameters!
				return false;
			}
			p = p->f_next;
			q = q->f_next;
		}
		if(p != 0 || q != 0) {
			// incompatible parameters!
			return false;
		}
		// compatible, but the caller needs to delete these Params
		return true;
	}

	void AddFunc(const char *name)
	{
		// we expect names to be unique; this will be checked
		// by the C++ compiler anyway...
		f_funcs = new Func(f_funcs, name);
		f_func_count++;
	}

	Dynamic *Next(void) { return f_next; }
	long Line(void) const { return f_line; }
	Param *GetParams(void) { return f_params; }

	bool GetTimed(void) const { return f_timed; }
	void SetTimed(bool timed = true) { f_timed = timed; }

	void Output(Lex& lex, FILE *h, FILE *cpp, const char *class_name);

private:
	Dynamic *f_next;
	long f_line;
	char *f_name;
	Param *f_params;
	long f_func_count;
	Func *f_funcs;
	bool f_timed;
};


class Lex
{
public:
	enum {
		NUL,
		NUMBER,
		STRING,
		CHARACTER,
		IDENTIFIER
	};

	Lex(const char *filename, const char *input);
	~Lex();
	int GetToken(void);
	void Write(FILE *f);
	const char *Filename(void) const { return f_filename; }
	long Line(void) const { return f_line; }
	const char *GetStart(void) const { return f_stoken; }
	const char *GetEnd(void) const { return f_etoken; }

	void StartDynamic(void);
	void TimedDynamic(void);
	bool AddDynamic(Param *p, const char *name, const char *func);
	Dynamic *GetDynamic(void) { return f_dynamics; }
	void ClearDynamic(void);

private:
	int GetC(void);
	void UngetC(void);
	int SubGetToken(void);

	long		f_line;		// current line
	const char *	f_filename;	// name of the file being parsed
	const char *	f_input;	// current position in input buffer
	const char *	f_start;	// start of the last time we wrote to output
	const char *	f_stoken;	// start/end token
	const char *	f_etoken;

	Dynamic *	f_dynamics;	// the list of dynamic functions & their parameters
	Dynamic *	f_start_dynamics;
};


Lex::Lex(const char *filename, const char *input)
{
	f_line  = 1;
	f_filename = filename;
	f_input = input;
	f_start = input;
	f_dynamics = 0;
}


Lex::~Lex()
{
	ClearDynamic();
}


void Lex::ClearDynamic(void)
{
	delete f_dynamics;
	f_dynamics = 0;
}


void Lex::StartDynamic(void)
{
	// mark the start to avoid 2 dynamics
	f_start_dynamics = f_dynamics;
}


void Lex::TimedDynamic(void)
{
	Dynamic *d;

	d = f_dynamics;
	while(d != f_start_dynamics) {
		d->SetTimed();
		d = d->Next();
	}
}


bool Lex::AddDynamic(Param *p, const char *name, const char *func)
{
	Dynamic *d;

	d = f_dynamics;
	while(d != f_start_dynamics && d != 0) {
		if(strcmp(name, d->GetName()) == 0) {
			fprintf(stderr, "%s:%ld: error: the dynamic function named \"%s\" is defined twice (first defined at line %ld)\n", f_filename, f_line, name, d->Line());
			g_errcnt++;
			return false;
		}
		d = d->Next();
	}

	d = f_dynamics;
	while(d != 0) {
		if(strcmp(name, d->GetName()) == 0) {
			if(!d->CheckParams(p)) {
				fprintf(stderr, "%s:%ld: error: the parameters of the dynamic functions defined on line %ld and the one on line %ld are not compatible\n", f_filename, f_line, f_line, d->Line());
				g_errcnt++;
			}
			else {
				d->AddFunc(func);
			}
			return false;
		}
		d = d->Next();
	}

	f_dynamics = new Dynamic(f_dynamics, f_line, p, name);
	f_dynamics->AddFunc(func);

	return true;
}


int Lex::GetC(void)
{
#if 0
if(*f_input < ' ') {
	printf("%p - Char [^%c]\n", f_input, *f_input + '@');
}
else {
	printf("%p - Char [%c]\n", f_input, *f_input);
}
#endif

	for(;;) switch(*f_input) {
	case '\0':
		return '\0';

	case '\r':
		if(f_input[1] == '\n') {
			f_input++;
		}
	case '\n':
		f_input++;
		f_line++;
		return '\n';

	default:
		f_input++;
		return f_input[-1];

	}
}

void Lex::UngetC(void)
{
	if(f_input[0] == '\0') {
		return;
	}

	if(f_input[-1] == '\n' || f_input[-1] == '\r') {
		f_line--;
	}

	f_input--;
}

int Lex::SubGetToken(void)
{
	int c, n;

	for(;;) {
		f_stoken = f_input;

		c = GetC();
		switch(c) {
		case 0:
			return 0;

		case '0':
			c = GetC();
			if(c == 'x' && c == 'X') {
				do {
					c = GetC();
				} while((c >= '0' && c <= '9')
					|| (c >= 'a' && c <= 'f')
					|| (c >= 'A' && c <= 'F'));
				return NUMBER;
			}
			// here we could test for octal, but it doesn't
			// matter too much here, we're not a compiler!
			UngetC();
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			do {
				c = GetC();
			} while(c >= '0' && c <= '9');
			if(c == 'U' || c == 'u') {
				c = GetC();
				if(c == 'L' || c == 'l') {
					c = GetC();
					if(c != 'L' && c != 'l') {
						UngetC();
					}
					return NUMBER;
				}
				// a U by itself is ignored
				UngetC();
				return NUMBER;
			}
			if(c == 'L' || c == 'l') {
				c = GetC();
				if(c != 'L' && c != 'l') {
					UngetC();
				}
				return NUMBER;
			}
			if(c == '.') {
				do {
					c = GetC();
				} while(c >= '0' && c <= '9');
			}
			if(c == 'e' || c == 'E') {
				c = GetC();
				if(c == '-' || c == '+') {
					c = GetC();
				}
				while(c >= '0' && c <= '9') {
					c = GetC();
				}
			}
			if(c == 'f' || c == 'F') {
				return NUMBER;
			}
			UngetC();
			return NUMBER;

		case '\'':
character:
			c = GetC();
			if(c == '\\') {
				c = GetC();
			}
			c = GetC();
			if(c != '\'') {
				fprintf(stderr, "%s:%ld: error: invalid character\n", f_filename, f_line);
				g_errcnt++;
			}
			return CHARACTER;

		case '"':
string:
			do {
				c = GetC();
				if(c == '\n' || c == '\0') {
					fprintf(stderr, "%s:%ld: error: unterminated string\n", f_filename, f_line);
					g_errcnt++;
					break;
				}
				if(c == '\\') {
					c = GetC();
					if(c == '\n' || c == '\0') {
						fprintf(stderr, "%s:%ld: error: unterminated string\n", f_filename, f_line);
						g_errcnt++;
						break;
					}
					c = '\0';
				}
			} while(c != '"');
			return STRING;

		case 'l':
		case 'L':
			c = GetC();
			if(c == '"') {
				goto string;
			}
			if(c == '\'') {
				goto character;
			}

		// comments are very simply ignored
		case '/':
			n = GetC();
			if(n == '/') {
				do {
					c = GetC();
				} while(c != '\n' && c != '\0');
				break;
			}
			if(n == '*') {
				n = GetC();
				do {
					c = n;
					n = GetC();
				} while(n != '\0' && (c != '*' || n != '/'));
				break;
			}
			UngetC();
			return c;

		default:
			if( isalpha(c) || (c=='_') || (c==':') )
			{
				do {
					c = GetC();
				} while((c >= 'a' && c <= 'z')
					|| (c >= 'A' && c <= 'Z')
					|| (c >= '0' && c <= '9')
					|| c == '_' || c == ':');
				UngetC();
				return IDENTIFIER;
			}
			else
			{
				return c;
			}

		}
	}
}


int Lex::GetToken(void)
{
	int t = SubGetToken();
	f_etoken = f_input;

// we ignore \r and \n in the tokens!
// (actually, only \r can be included, but just in case we check both)
#if 0
	while(f_etoken > f_stoken
	  && (f_etoken[-1] == '\r' || f_etoken[-1] == '\n')) {
		--f_etoken;
	}
#endif

#if 0
if(f_stoken != f_etoken) {
printf("Got token [%.*s] type = %d\n", f_etoken - f_stoken, f_stoken, t);
fflush(stdout);
}
#endif

	return t;
}


void Lex::Write(FILE *f)
{
	size_t l = f_etoken - f_stoken;
	size_t w = fwrite(f_stoken, 1, l, f);
	if(l != w) {
		fprintf(stderr, "%s:%ld: error: i/o error while writing to output file", f_filename, f_line);
		g_errcnt++;
	}
#ifdef MO_DEBUG
	else {
		fflush(f);
	}
#endif
}



void Dynamic::Output(Lex& lex, FILE *h, FILE *cpp, const char *class_name)
{
	static int	count = 0;
	Param		*next;
	Func		*func;

	count++;

	fprintf(cpp,
"struct __func%d_t {\n"
"\tmolib::mo_name_t f_name;\n"
"\tvoid (%s::*f_func)(", count, class_name);

	if(f_timed) {
		fprintf(cpp, "time_t __time");
	}

	next = f_params;
	while(next != 0) {
		if(next != f_params || f_timed) {
			fprintf(cpp, ", ");
		}
		fprintf(cpp, "%s", next->f_type);
		next = next->f_next;
	}

	fprintf(cpp, ");\n"
"};\n"
"static molib::moBase::compare_t __compare_func%d(const void *a, const void *b)\n"
"{\n"
"\treturn molib::moBase::CompareInt("
	"reinterpret_cast<const __func%d_t *>(a)->f_name, "
	"reinterpret_cast<const __func%d_t *>(b)->f_name);\n"
"}\n"
, count, count, count);

	fprintf(h, "\tvirtual void %s(const molib::moName& __name", f_name);
	fprintf(cpp, "void %s::%s(const molib::moName& __name", class_name, f_name);

	if(f_timed) {
		fprintf(h, ", time_t __time");
		fprintf(cpp, ", time_t __time");
	}

	next = f_params;
	while(next != 0) {
		fprintf(h, ", %s", next->f_type);
		fprintf(cpp, ", %s", next->f_type);
		if(next->f_default_value != 0) {
			fprintf(h, " = %s", next->f_default_value);
		}
		next = next->f_next;
	}
	fprintf(h, ");\n");

	fprintf(cpp,
")\n"
"{\n"
"\tmolib::moSortedArray __array(sizeof(__func%d_t), &__compare_func%d);\n"
"\t__func%d_t __f;\n"
"\tif(__array.Count() == 0) {\n"
"\t\tconst molib::moNamePool& __pool = molib::moNamePool::GetNamePool();\n",
		count, count, count);

	// We first insert all the '*::<name>' because
	// they will always be in front of all the other
	// entries! (the name of an interface has to
	// start with [A-Za-z_])
	func = f_funcs;
	while(func != 0) {
		fprintf(cpp,
"\t\t__f.f_name = __pool.Get(\"*::%s\");\n"
"\t\t__f.f_func = &%s::%s;\n"
"\t\t__array.Insert(&__f);\n",
			func->GetName(),
			class_name, func->GetName());
		func = func->Next();
	}

	func = f_funcs;
	while(func != 0) {
		fprintf(cpp,
"\t\t__f.f_name = __pool.Get(\"%s::%s\");\n"
"\t\t__f.f_func = &%s::%s;\n"
"\t\t__array.Insert(&__f);\n",
			class_name, func->GetName(),
			class_name, func->GetName());
		func = func->Next();
	}

	fprintf(cpp,
"\t}\n"
"\t__f.f_name = __name;\n"
"\tmolib::moArray::position_t __pos = __array.Find(&__f);\n"
"\tif(__pos != molib::moArray::NO_POSITION) {\n"
"\t\t(this->*reinterpret_cast<const __func%d_t *>(__array.Get(__pos))->f_func)(", count);

	if(f_timed) {
		fprintf(cpp, "__time");
	}

	next = f_params;
	while(next != 0) {
		if(next != f_params || f_timed) {
			fprintf(cpp, ", ");
		}
		fprintf(cpp, "%s", next->f_name);
		next = next->f_next;
	}

	fprintf(cpp, ");\n"
"\t}\n"
"}\n"
"\n");


}



int get_param(Lex& lex, Param *& p)
{
	const char *s, *e;
	int t, paren;
	p = 0;
	for(;;) {
		do {
			t = lex.GetToken();
		} while(isspace(t) || t == '\n');
		if(t == '\0') {
			return t;
		}
		if(t == ',' || t == ')') {
			if(p == 0) {
				if(t == ',') {
					fprintf(stderr, "%s:%ld: error: , not expected here\n", lex.Filename(), lex.Line());
					g_errcnt++;
				}
				return t;
			}
			break;
		}
		if(p == 0) {
			p = new Param;
		}

		if(t == '=') {
			break;
		}
		s = lex.GetStart();
		if(t == '(') {
			p->f_function = true;
			paren = 1;
			do {
				t = lex.GetToken();
				if(t == '(') {
					paren++;
				}
				else if(t == ')') {
					paren--;
				}
			} while(paren != 0 && t != '\0');
		}
		e = lex.GetEnd();

		p->AppendType(s, static_cast<int>(e - s));
	}

// if the type is just 'void' and t is ')' then we don't want it
	if(strcmp(p->f_type, "void") == 0) {
		if(t != ')') {
			fprintf(stderr, "%s:%ld: error: invalid usage of type void\n", lex.Filename(), lex.Line());
			g_errcnt++;
			return t;
		}
		delete p;
		p = 0;
		return t;
	}

// compute the name of the parameter
	p->DefineName();

// special case of default values
	if(t == '=') {
		do {
			t = lex.GetToken();
		} while(isspace(t) || t == '\n');
		if(t == '\0') {
			return t;
		}
		if(t == ',') {
			fprintf(stderr, "%s:%ld: error: default value missing for parameter %s\n", lex.Filename(), lex.Line(), p->f_type);
			g_errcnt++;
			return t;
		}
		s = lex.GetStart();
		do {
			e = lex.GetEnd();
			t = lex.GetToken();
		} while(t != ',' && t != ')' && t != '\0');
		if(t == '\0') {
			return t;
		}
		p->SetDefaultValue(s, static_cast<long>(e - s));
	}

	return t;
}



void convert_async(Lex& lex, const char *class_name, FILE *h, FILE *cpp)
{
	int		t, l;
	const char	*s, *e;
	Param		*params, *last, *next;
	bool		keep_params, timed_async, dynamic_event;

	keep_params = false;
	timed_async = false;
	dynamic_event = false;

	// we can have multiple dynamic as long as each have a different
	// function name; also, we need to mark them as being timed if
	// the timed flag is also specified
	lex.StartDynamic();

// first we parse the function
	// skip spaces
	do {
		t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t == '\0') {
eof:
		fprintf(stderr, "%s:%ld: error: EOF reached within an async declaration\n", lex.Filename(), lex.Line());
		g_errcnt++;
		return;
	}

	if(t != Lex::IDENTIFIER) {
		fprintf(stderr, "%s:%ld: error: async not followed by an identifier\n", lex.Filename(), lex.Line());
		g_errcnt++;
		return;
	}

	// we expect the name of the function
	s = lex.GetStart();
	e = lex.GetEnd();
	l = static_cast<int>(e - s);
	char* name = new char[l + 1];
	str_keeper sk(name);
	memcpy(name, s, l);
	name[l] = '\0';

	do {
		t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t == '\0') {
		goto eof;
	}

	if(t != '(') {
		fprintf(stderr, "%s:%ld: error: async function name not followed by (\n", lex.Filename(), lex.Line());
		g_errcnt++;
		return;
	}

	// now we read the parameters
	last = params = 0;
	do {
		t = get_param(lex, next);
		if(next != 0) {
			if(last != 0) {
				last->f_next = next;
			}
			if(params == 0) {
				params = next;
			}
			last = next;
		}
	} while(t != ')' && t != '\0');
	if(t == '\0') {
		goto eof;
	}

	// right after the ')' we can have a dynamic attribute!
	// the syntax is:
	//	__attribute__ ((dynamic[([<identifier>])]))
	do {
		 t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t != Lex::IDENTIFIER) {
		goto no_attribute;
	}
	s = lex.GetStart();
	e = lex.GetEnd();
	l = static_cast<int>(e - s);
	if(l != 13 || memcmp(s, "__attribute__", l) != 0) {
		fprintf(stderr, "%s:%ld: error: the keyword __attribute__ or = 0 was expected\n", lex.Filename(), lex.Line());
		g_errcnt++;
		goto skip_attr;
	}
	do {
		 t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t != '(') {
		fprintf(stderr, "%s:%ld: error: the keyword __attribute__ is expected to be followed by two '('\n", lex.Filename(), lex.Line());
		g_errcnt++;
		goto skip_attr;
	}
	do {
		 t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t != '(') {
		fprintf(stderr, "%s:%ld: error: the keyword __attribute__ is expected to be followed by two '('\n", lex.Filename(), lex.Line());
		g_errcnt++;
		goto skip_attr;
	}
more_attributes:
	do {
		 t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t != Lex::IDENTIFIER) {
		goto empty_attribute;
	}
	s = lex.GetStart();
	e = lex.GetEnd();
	l = static_cast<int>(e - s);
	if(l == 5 && memcmp(s, "timed", l) == 0) {
		timed_async = true;
		do {
			 t = lex.GetToken();
		} while(isspace(t) || t == '\n');
		goto empty_attribute;
	}
	else if(l == 13 && memcmp(s, "dynamic_event", l) == 0) {
		dynamic_event = true;
		do {
			 t = lex.GetToken();
		} while(isspace(t) || t == '\n');
		goto empty_attribute;
	}
	else if(l != 7 || memcmp(s, "dynamic", l) != 0) {
		fprintf(stderr, "%s:%ld: error: only one of 'timed' or 'dynamic' is supported as an attribute\n", lex.Filename(), lex.Line());
		g_errcnt++;
		do {
			 t = lex.GetToken();
		} while(isspace(t) || t == '\n');
		goto empty_attribute;
	}
	do {
		 t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t == '(') {
		// a user name may be specified!
		do {
			 t = lex.GetToken();
		} while(isspace(t) || t == '\n');
		if(t == Lex::IDENTIFIER) {
			s = lex.GetStart();
			e = lex.GetEnd();
			l = static_cast<int>(e - s);
			char* dname = new char[l + 1];
			str_keeper sk(dname);
			memcpy(dname, s, l);
			dname[l] = '\0';

// here we have (1) the name of the dynamic function
//		(2) the list of parameters for that function

			keep_params = lex.AddDynamic(params, dname, name);

			do {
				 t = lex.GetToken();
			} while(isspace(t) || t == '\n');
		}
		else {
			keep_params = lex.AddDynamic(params, "DynamicEvent", name);
		}
		if(t != ')') {
			fprintf(stderr, "%s:%ld: error: a ')' was expected after the dynamic attribute name\n", lex.Filename(), lex.Line());
			g_errcnt++;
			goto skip_attr;
		}
		do {
			 t = lex.GetToken();
		} while(isspace(t) || t == '\n');
	}
	else {
		keep_params = lex.AddDynamic(params, "DynamicEvent", name);
	}
empty_attribute:
	if(t == ',') {
		goto more_attributes;
	}
	if(t != ')') {
		fprintf(stderr, "%s:%ld: error: two ')' were expected to terminate the __attribute__\n", lex.Filename(), lex.Line());
		g_errcnt++;
		goto skip_attr;
	}
	do {
		 t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t != ')') {
		fprintf(stderr, "%s:%ld: error: two ')' were expected to terminate the __attribute__\n", lex.Filename(), lex.Line());
		g_errcnt++;
	}


skip_attr:
	// at the end we expect ' = 0'
	do {
		 t = lex.GetToken();
	} while(isspace(t) || t == '\n');
no_attribute:
	if(t != '=') {
		fprintf(stderr, "%s:%ld: error: = 0 is expected for all async functions\n", lex.Filename(), lex.Line());
		g_errcnt++;
	}
	else {
		do {
			t = lex.GetToken();
		} while(isspace(t) || t == '\n');
		if(t != Lex::NUMBER) {
			fprintf(stderr, "%s:%ld: error: = 0 is expected for all async functions\n", lex.Filename(), lex.Line());
			g_errcnt++;
		}
		else {
			// WARNING: we're not testing the number, we expect 0...
			t = lex.GetToken();
		}
	}

	if(t != ';') {
		fprintf(stderr, "%s:%ld: error: ; was expected at the end of a function declaration\n", lex.Filename(), lex.Line());
		g_errcnt++;
	}

// Finally, we got it all, let's convert the result...
	// declare the virtual function
	fprintf(h, "virtual void %s(", name);

	if(dynamic_event) {
		fprintf(h, "const molib::moName& __name");
	}

	next = params;
	if(next == 0) {
		if(!dynamic_event) {
			fprintf(h, "void");
		}
	}
	else {
		while(next != 0) {
			if(next != params) {
				fprintf(h, ", ");
			}
			fprintf(h, "%s", next->f_type);
			if(next->f_default_value != 0) {
				fprintf(h, " = %s", next->f_default_value);
			}
			next = next->f_next;
		}
	}
	fprintf(h, ") = 0;\n");

	// declare the static function
	fprintf(h, "\tstatic void Post%s(molib::moEventPipeBroadcast *__broadcast", name);
	fprintf(cpp, "void %s::Post%s(molib::moEventPipeBroadcast *__broadcast", class_name, name);

	if(dynamic_event) {
		fprintf(h, ", const molib::moName& __name");
		fprintf(cpp, ", const molib::moName& __name");
	}

	if(timed_async) {
		fprintf(h, ", time_t __time");
		fprintf(cpp, ", time_t __time");
	}

	next = params;
	while(next != 0) {
		fprintf(h, ", %s", next->f_type);
		fprintf(cpp, ", %s", next->f_type);
		if(next->f_default_value != 0) {
			fprintf(h, " = %s", next->f_default_value);
		}
		next = next->f_next;
	}
	fprintf(h, ");\n");

	fprintf(cpp,
")\n"
"{\n"
"\tclass __Event : public molib::moReceiversEvent\n"
"\t{\n"
"\tpublic:\n"
"\t\t__Event(");

	if(dynamic_event) {
		fprintf(cpp, "const molib::moName __name");
	}

	if(timed_async) {
		fprintf(cpp, "time_t __time");
	}

	next = params;
	if(next == 0) {
		if(!dynamic_event && !timed_async) {
			fprintf(cpp, "void");
		}
	}
	else {
		if(dynamic_event || timed_async) {
			fprintf(cpp, ", ");
		}
		fprintf(cpp, "%s", next->f_type);
		next = next->f_next;
		while(next != 0) {
			fprintf(cpp, ", %s", next->f_type);
			next = next->f_next;
		}
	}

	fprintf(cpp, ")\n"
"\t\t\t: molib::moReceiversEvent(\"%s\")",
		name);

	next = params;
	while(next != 0) {
		fprintf(cpp, ",\n"
"\t\t\t  f_%s(%s)", next->f_name, next->f_name);
		next = next->f_next;
	}

	if(dynamic_event) {
		fprintf(cpp, ",\n"
"\t\t\t  f___name(__name)");
	}

	fprintf(cpp, "\n"
"\t\t{\n");

	if(timed_async) {
		fprintf(cpp,
"\t\t\tSetTime(__time);\n"
);
	}

	fprintf(cpp,
"\t\t}\n"
"\t\t__Event(const __Event& event)\n"
"\t\t\t: molib::moReceiversEvent(event)");

	next = params;
	while(next != 0) {
		fprintf(cpp, ",\n"
"\t\t\t  f_%s(event.f_%s)", next->f_name, next->f_name);
		next = next->f_next;
	}

	if(dynamic_event) {
		fprintf(cpp, ",\n"
"\t\t\t  f___name(event.f___name)");
	}

	fprintf(cpp, "\n"
"\t\t{\n"
"\t\t}\n"
"\t\tconst char *GetClassName(void) const\n"
"\t\t{\n"
"\t\t\treturn \"molib::moBase::moEvent::__Event(%s)\";\n"
"\t\t}\n"
"\t\tvirtual molib::moEventSPtr Duplicate(void) const\n"
"\t\t{\n"
"\t\t\treturn new __Event(*this);\n"
"\t\t}\n"
"\t\tvirtual void SendToReceivers(const molib::moSortedList& receivers)\n"
"\t\t{\n"
"\t\t\tmolib::moList::position_t idx, max;\n"
"\t\t\t%s *r;\n"
"\t\t\tmax = receivers.Count();\n"
"\t\t\tfor(idx = 0; idx < max; ++idx) {\n"
"\t\t\t\tr = dynamic_cast<%s *>(receivers.Get(idx));\n"
"\t\t\t\tif(r != 0) {\n"
"\t\t\t\t\tr->%s(",
		name, class_name, class_name, name);

	if(dynamic_event) {
		fprintf(cpp, "f___name");
	}

	next = params;
	while(next != 0) {
		if(next != params || dynamic_event) {
			fprintf(cpp, ", ");
		}
		fprintf(cpp, "f_%s", next->f_name);
		next = next->f_next;
	}

	fprintf(cpp, ");\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t}\n");

	if(params != 0) {
		fprintf(cpp,
"\tprivate:\n");

		next = params;
		while(next != 0) {
			fprintf(cpp, "\t\t%s;\n", next->FType());
			next = next->f_next;
		}
	}

	if(dynamic_event) {
		fprintf(cpp, "\t\tmolib::moName f___name;\n");
	}

	fprintf(cpp,
"\t} __event");

	if(params != 0 || dynamic_event || timed_async) {
		fprintf(cpp, "(");

		if(dynamic_event) {
			fprintf(cpp, "__name");
		}

		if(timed_async) {
			fprintf(cpp, "%s__time", dynamic_event ? ", " : "");
		}

		next = params;
		if(next != 0) {
			if(dynamic_event || timed_async) {
				fprintf(cpp, ", ");
			}
			fprintf(cpp, "%s", next->f_name);
			next = next->f_next;
			while(next != 0) {
				fprintf(cpp, ", %s", next->f_name);
				next = next->f_next;
			}
		}

		fprintf(cpp, ")");
	}

	fprintf(cpp, ";\n"
"\t__broadcast->Post(__event);\n"
"}\n"
"\n");

	if(timed_async) {
		lex.TimedDynamic();
	}

	if(!keep_params) {
		delete params;
	}
}




void parse_class(Lex& lex, FILE *h, FILE *cpp)
{
	int		t, l, brackets;
	const char	*s, *e;

	do {
		t = lex.GetToken();
		lex.Write(h);
	} while(isspace(t) || t == '\n');
	if(t != Lex::IDENTIFIER) {
		// is it possible that we don't have an identifier after the keyword class?!
		fprintf(stderr, "%s:%ld: error: expected an identifier after the 'class' keyword\n", lex.Filename(), lex.Line());
		g_errcnt++;
		return;
	}
	// we got the class name!
	s = lex.GetStart();
	e = lex.GetEnd();
	l = static_cast<int>(e - s);
	char* class_name = new char[l + 1];
	str_keeper sk(class_name);
	memcpy(class_name, s, l);
	class_name[l] = '\0';

	brackets = 0;
	for(;;) {
		t = lex.GetToken();
		if(t == '\0') {
			// that's a big problem in the source file!
			return;
		}
		if(t == ';') {
			if(brackets == 0) {
				// in this special case, we don't have a full declaration
				// i.e.:   class Stuff;
				lex.Write(h);
				return;
			}
		}
		else if(t == '{') {
			brackets++;
		}
		else if(t == '}') {
			if(brackets == 0) {
				fprintf(stderr, "%s:%ld: error: could not find { in a class definition\n", lex.Filename(), lex.Line());
				g_errcnt++;
			}
			else {
				brackets--;
			}
			if(brackets == 0) {
				break;
			}
		}
		else if(t == Lex::IDENTIFIER) {
			s = lex.GetStart();
			e = lex.GetEnd();
			if(e - s == 5 && memcmp(s, "class", 5) == 0) {
				// warning: this is a recursive call...
				lex.Write(h);
				parse_class(lex, h, cpp);
			}
			else if(e - s == 5 && memcmp(s, "async", 5) == 0) {
				// we found an asynchroneous function
				convert_async(lex, class_name, h, cpp);
				continue;
			}
		}
		lex.Write(h);
	}
	// once a class is being closed, we need to put the dynamic
	// functions if any were defined
	Dynamic *d = lex.GetDynamic();
	if(d != 0) {
		fprintf(h, "public:\n");
		while(d != 0) {
			d->Output(lex, h, cpp, class_name);
			d = d->Next();
		}
	}
	lex.ClearDynamic();
	// we don't expect the lexical input to be messed up by
	// the Dynamic::Output() calls...
	lex.Write(h);
}


void convert_file(const char *filename, const char *input, FILE *h, FILE *cpp)
{
	int		t;
	const char	*s, *e;
	Lex		lex(filename, input);

	for(;;) {
		t = lex.GetToken();
		if(t == '\0') {
			break;
		}
		lex.Write(h);
		if(t == Lex::IDENTIFIER) {
			s = lex.GetStart();
			e = lex.GetEnd();
			if(e - s == 5 && memcmp(s, "class", 5) == 0) {
				parse_class(lex, h, cpp);
			}
		}
	}
}



void remove_cr(char *input)
{
	char *d;

	d = input;
	while(*input != '\0') {
		if(*input == '\r') {
			if(input[1] == '\n') {
				input++;
			}
			else {
				*input = '\n';
			}
		}
		*d++ = *input++;
	}
	*d = '\0';
}


void parse(const char *filename)
{
	FILE		*f, *h, *cpp;
	const char	*ext, *basename;
	char		*input;
	long		len;

/* make sure the extension is .async */
	ext = strrchr(filename, '.');
	if(ext == 0 || strcmp(".async", ext) != 0) {
		return;
	}

/* open the input file */
	f = fopen(filename, "rb");
	if(f == 0) {
		fprintf(stderr, "%s:0: error: cannot open file\n", filename);
		return;
	}

/* open the output files */
	basename = strrchr(filename, '/');
	if(basename == 0) {
		basename = strrchr(filename, '\\');
		if(basename == 0) {
			basename = filename;
		}
		else {
			basename++;
		}
	}
	else {
		basename++;
	}
	len = static_cast<long>(strlen(basename) - size_t(6));	// strlen(".async") == 6
	h = open_output(basename, len, ".h");
	cpp = open_output(basename, len, ".c++");

	if(h == 0 || cpp == 0) {
		if(h != 0) {
			fclose(h);
		}
		if(cpp != 0) {
			fclose(cpp);
		}
		fclose(f);
		return;
	}

	input = read_input(filename, f);

	if(input != 0) {
		// mo_event.h needs to be included from within the .async file!
		//fprintf(h, "#include <mo_event.h>\n");

		// auto-include the header
		fprintf(cpp, "#include \"%.*s.h\"\n", static_cast<int>(len), basename);

		remove_cr(input);
		convert_file(filename, input, h, cpp);
		delete [] input;

		// Need extra newline at end of file to keep compiler from complaining.
		fprintf(h, "\n" );
	}

	fclose(f);
	fclose(h);
	fclose(cpp);
}




void usage(const char *argv0)
{
	fprintf(stderr, "Usage: %s [-opts] file ...\n", argv0);
	fprintf(stderr, "where -opts is one or more of the following:\n");
	fprintf(stderr, "  -f or --force          replace the output even if it is a user file\n");
	fprintf(stderr, "  -h or --help           print out this usage screen\n");
	fprintf(stderr, "  -o or --output <path>  a path where to save the output files (default: .)\n");
	exit(1);
}

int main(int argc, const char *argv[])
{
	int		i, j, max;
	bool		filenames_only;

	filenames_only = 0;

	i = 1;
	for(i = 1; i < argc; ++i) {
		if(argv[i][0] == '-' && !filenames_only) {
			if(argv[i][1] == '-') {
				// long options
				if(argv[i][2] == '0') {
					filenames_only = 1;
				}
				else if(strcmp(argv[i] + 2, "help") == 0) {
					usage(argv[0]);
					/*NOTREACHED*/
				}
				else if(strcmp(argv[i] + 2, "force") == 0) {
					g_force = true;
				}
				else if(strcmp(argv[i] + 2, "output") == 0) {
					i++;
					if(i >= argc) {
						fprintf(stderr, "<no file>:0: error: expected a path after --output\n");
						usage(argv[0]);
						/*NOTREACHED*/
					}
					setoutput(argv[i]);
				}
				else {
					fprintf(stderr, "<no file>:0: error: unknown option '%s'\n", argv[i]);
					usage(argv[0]);
					/*NOTREACHED*/
				}
			}
			else {
				max = static_cast<int>(strlen(argv[i]));
				for(j = 1; j < max; ++j) {
					switch(argv[i][j]) {
					case 'f':
						g_force = true;
						break;

					default:
						fprintf(stderr, "<no file>:0: error: unknown option '-%c'\n", argv[i][j]);
					case 'h':
						usage(argv[0]);
						/*NOTREACHED*/

					case 'o':
						/* hmmm 1 */
						i++;
						if(i >= argc) {
							fprintf(stderr, "<no file>:0: error: expected a path after --output\n");
							usage(argv[0]);
							/*NOTREACHED*/
						}
						setoutput(argv[i]);
						/* hmmm 2 */
						j = max;
						break;

					}
				}
			}
		}
		else {
			parse(argv[i]);
		}
	}

	return g_errcnt > 0 ? 1 : 0;
}


// vim: ts=8 sw=8
