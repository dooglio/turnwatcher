//
// Object:	Replace transaction functions in a .trans file into the necessary header and .c++
// Copyright:	Copyright (c) 2007-2008 Made to Order Software Corp.
//		All Rights Reserved.
//
//		This software and its associated documentation contains
//		proprietary, confidential and trade secret information
//		of Made to Order Software Corp. and except as provided by
//		written agreement with Made to Order Software Corp.
//
//		a) no part may be disclosed, distributed, reproduced,
//		   transmitted, transcribed, stored in a retrieval system,
//		   adapted or translated in any form or by any means
//		   electronic, mechanical, magnetic, optical, chemical,
//		   manual or otherwise,
//
//		and
//
//		b) the recipient is not entitled to discover through reverse
//		   engineering or reverse compiling or other such techniques
//		   or processes the trade secrets contained therein or in the
//		   documentation.
//
//

#include	<stdlib.h>
#include	<stdio.h>
#ifndef _MSC_VER
#include	<unistd.h>
#endif
#include	<string.h>
#include	<errno.h>
#include	<ctype.h>
#include	<string>
#include	<memory>


#ifdef _MSC_VER
#pragma warning(disable: 4996)
#endif


bool		g_force;
char *		g_output = const_cast<char*>("./");
int		g_errcnt;
const char	g_auto_generated[] = "/* this file was auto-generated by the transaction_builder tool */";

void setoutput(const char *output)
{
	unsigned long	o;

	// can't accept empty output path
	if(output == 0 || *output == '\0') {
		output = "./";
	}

	// check whether we need to add '/' at the end
	o = static_cast<unsigned long>(strlen(output));
	if(output[o - 1] != '/') {
		// This is a leak and that's fine, this is a Unix tool
		g_output = new char[o + 2];
		memcpy(g_output, output, o);
		g_output[o] = '/';
		g_output[o + 1] = '\0';
	}
	else {
		// perfect, save it as is
		g_output = (char *) output;
	}
}

FILE *open_output(const char *filename, long len, const char *ext)
{
	FILE		*f;
	unsigned long	l, o;
	char		buf[256];

	l = static_cast<unsigned long>(strlen(ext));
	o = static_cast<unsigned long>(strlen(g_output));	// already include '/' at the end

	std::auto_ptr<char> n(new char[o + len + l + 1]);
	char *name = n.get();
	memcpy(name, g_output, o);
	memcpy(name + o, filename, len);
	memcpy(name + o + len, ext, l);
	name[o + len + l] = '\0';
	if(!g_force) {
		f = fopen(name, "rb");
		if(f != 0) {
			// the file already exists, let's make sure we're not
			// overwriting some random user file
			l = static_cast<unsigned long>(fread(buf, 1, sizeof(g_auto_generated) - 1, f));
			fclose(f);
			if(l != sizeof(g_auto_generated) - 1
			|| memcmp(buf, g_auto_generated, sizeof(g_auto_generated) - 1) != 0) {
				fprintf(stderr, "%s:1: error: cannot overwrite file; it does not look like an auto-generated file\n", name);
				g_errcnt++;
				return 0;
			}
		}
	}

	f = fopen(name, "wb");
	if(f == 0) {
		fprintf(stderr, "%s:0: error: cannot open file\n", name);
		g_errcnt++;
	}
	else {
		// always write that at the very beginning
		l = fprintf(f, "%s\n", g_auto_generated);
		// TODO: working under Mingw?! fprintf() does not return count, right?
		//	 Well... not too sure, but we can compile under MinGW now.
		if(l < sizeof(g_auto_generated)) {
			fclose(f);
			remove(name);
			fprintf(stderr, "%s:1: error: cannot write into output file\n", name);
			g_errcnt++;
			f = 0;
		}
		else {
			fflush(f);
		}
	}

	return f;
}


char *read_input(const char *filename, FILE *f)
{
	size_t size, sz;
	char *buf;
	int e;
	fseek(f, 0, SEEK_END);
	size = ftell(f);
	fseek(f, 0, SEEK_SET);
	buf = new char[size + 1];
	buf[size] = '\0';
	sz = fread(buf, 1, size, f);
	if(sz != size) {
		g_errcnt++;
		e = errno;
		fprintf(stderr, "%s:1: error: ", filename);
		errno = e;
		perror(0);
		delete [] buf;
		return 0;
	}
	return buf;
}

class Param
{
public:
	Param(void)
	{
		f_next = 0;
		f_type = 0;
		f_ftype = 0;
		f_fullname = 0;
		f_name = 0;
		f_default_value = 0;
		f_function = false;
	}

	~Param()
	{
		delete f_next;
		delete [] f_type;
		delete [] f_ftype;
		delete [] f_fullname;
		// f_name is a pointer within f_fullname
		delete [] f_default_value;
	}

	void AppendType(const char *s, int l)
	{
		char *d;
		// we could assume that isn't possible...
		while(l > 0 && isspace(*s)) {
			s++;
			l--;
		}
		if(f_type == 0) {
			f_type = new char[l + 1];
			d = f_type;
		}
		else {
			size_t sz = strlen(f_type);
			char *n = new char[sz + l + 2];
			memcpy(n, f_type, sz);
			n[sz] = ' ';	// separated by a space
			delete [] f_type;
			f_type = n;
			d = f_type + sz + 1;
		}
		while(l > 0) {
			l--;
			// transform all spaces in ' '
			if(*s == '\n' || isspace(*s)) {
				*d = ' ';
			}
			else {
				*d = *s;
			}
			// avoid two spaces one after another
			if(d <= f_type || d[0] != ' ' || d[-1] != ' ') {
				d++;
			}
			s++;
		}
		// remove spaces from the end
		while(d > f_type && d[-1] == ' ') {
			d--;
		}
		*d = '\0';
	}

	void SetDefaultValue(const char *s, long l)
	{
		delete f_default_value;
		f_default_value = new char[l + 1];
		memcpy(f_default_value, s, l);
		f_default_value[l] = '\0';
	}

	void DefineName(void)
	{
		if(f_type == 0) {
			return;
		}
		if(*f_type == '\0') {
			return;
		}
		int l;
		bool cpp = false;
		const char *s, *n;
		s = f_type;
		if(f_function) {
			while(*s != '(' && *s != '\0') {
				s++;
			}
			// this shouldn't happen since f_function is set
			// to true whenever '(' is found in the type
			if(*s != '(') {
				return;
			}
			do {
				s++;
			} while(*s == '*' || *s == ' ');
			// a C++ function name can include a class/namespace:
			//	void (moBase::*func)()
			n = s;
			while((*s >= 'a' && *s <= 'z')
			   || (*s >= 'A' && *s <= 'Z')
			   || (*s >= '0' && *s <= '9')
			   || *s == '_' || *s == ':' || *s == '*') {
				if(*s == '*') {
					cpp = true;
				}
				s++;
			}
		}
		else {
			// the name is the last word in this case
			n = s;
			while(*s != '\0') {
				if(isspace(*s)) {
					n = s + 1;
				}
				s++;
			}
		}
		delete [] f_fullname;
		l = static_cast<int>(s - n);
		f_fullname = new char[l + 1];
		memcpy(f_fullname, n, l);
		f_fullname[l] = '\0';
		if(cpp) {
			f_name = strrchr(f_fullname, '*') + 1;
		}
		else {
			f_name = f_fullname;
		}
	}

	const char *FType(void)
	{
		if(f_ftype != 0) {
			return f_ftype;
		}
		if(f_type == 0) {
			return "";
		}
		if(*f_type == '\0') {
			return "";
		}
		size_t l = strlen(f_type);
		delete [] f_ftype;
		f_ftype = new char[l + 5];
		f_ftype[l + 4] = '\0';
		const char *s = strrchr(f_type, '*');
		if(f_function && s != 0) {
			s++;
			while(*s == ' ') {
				s++;
			}
			size_t p = s - f_type;
			memcpy(f_ftype, f_type, p);
			f_ftype[p] = '_';
			f_ftype[p + 1] = '_';
			f_ftype[p + 2] = 'f';
			f_ftype[p + 3] = '_';
			memcpy(f_ftype + p + 4, s, l - p);
		}
		else {
			const char *s = strrchr(f_type, ' ');
			if(s == 0) {
				s = f_type;
			}
			else {
				s++;
			}
			size_t p = s - f_type;
			memcpy(f_ftype, f_type, p);
			f_ftype[p] = '_';
			f_ftype[p + 1] = '_';
			f_ftype[p + 2] = 'f';
			f_ftype[p + 3] = '_';
			strcpy(f_ftype + p + 4, s);
		}

		return f_ftype;
	}

	static int mystrcmp(const char *a, const char *b)
	{
		if(a == 0) {
			if(b == 0) {
				return 0;
			}
			if(*b == '\0') {
				return 0;
			}
			return -1;
		}
		if(b == 0) {
			if(*a == '\0') {
				return 0;
			}
			return 1;
		}
		return strcmp(a, b);
	}

	bool operator == (const Param& p) const
	{
		return mystrcmp(f_fullname, p.f_fullname) == 0
		    // f_name is part of fullname -- already compared
		    && mystrcmp(f_type, p.f_type) == 0
		    // f_ftype is part of fullname -- already compared
		    && mystrcmp(f_default_value, p.f_default_value) == 0
		    && f_function == p.f_function;
	}

	Param *f_next;
	char *f_fullname;
	char *f_name;
	char *f_type;
	char *f_ftype;
	char *f_default_value;
	bool f_function;
};


class Lex
{
public:
	enum {
		NUL,
		NUMBER,
		STRING,
		CHARACTER,
		IDENTIFIER
	};

	Lex(const char *filename, const char *input);
	~Lex();
	int GetToken(void);
	void Write(FILE *f);
	const char *Filename(void) const { return f_filename; }
	long Line(void) const { return f_line; }
	const char *GetStart(void) const { return f_stoken; }
	const char *GetEnd(void) const { return f_etoken; }
	std::string GetString(void) const { return std::string(f_stoken, f_etoken - f_stoken); }

private:
	int GetC(void);
	void UngetC(void);
	int SubGetToken(void);

	long		f_line;		// current line
	const char *	f_filename;	// name of the file being parsed
	const char *	f_input;	// current position in input buffer
	const char *	f_start;	// start of the last time we wrote to output
	const char *	f_stoken;	// start/end token
	const char *	f_etoken;
};


Lex::Lex(const char *filename, const char *input)
{
	f_line  = 1;
	f_filename = filename;
	f_input = input;
	f_start = input;
}


Lex::~Lex()
{
}





int Lex::GetC(void)
{
#if 0
if(*f_input < ' ') {
	printf("%p - Char [^%c]\n", f_input, *f_input + '@');
}
else {
	printf("%p - Char [%c]\n", f_input, *f_input);
}
#endif

	for(;;) switch(*f_input) {
	case '\0':
		return '\0';

	case '\r':
		if(f_input[1] == '\n') {
			f_input++;
		}
	case '\n':
		f_input++;
		f_line++;
		return '\n';

	default:
		f_input++;
		return f_input[-1];

	}
}

void Lex::UngetC(void)
{
	if(f_input[0] == '\0') {
		return;
	}

	if(f_input[-1] == '\n' || f_input[-1] == '\r') {
		f_line--;
	}

	f_input--;
}

int Lex::SubGetToken(void)
{
	int c, n;

	for(;;) {
		f_stoken = f_input;

		c = GetC();
		switch(c) {
		case 0:
			return 0;

		case '0':
			c = GetC();
			if(c == 'x' && c == 'X') {
				do {
					c = GetC();
				} while((c >= '0' && c <= '9')
					|| (c >= 'a' && c <= 'f')
					|| (c >= 'A' && c <= 'F'));
				return NUMBER;
			}
			// here we could test for octal, but it doesn't
			// matter too much here, we're not a compiler!
			UngetC();
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			do {
				c = GetC();
			} while(c >= '0' && c <= '9');
			if(c == 'U' || c == 'u') {
				c = GetC();
				if(c == 'L' || c == 'l') {
					c = GetC();
					if(c != 'L' && c != 'l') {
						UngetC();
					}
					return NUMBER;
				}
				// a U by itself is ignored
				UngetC();
				return NUMBER;
			}
			if(c == 'L' || c == 'l') {
				c = GetC();
				if(c != 'L' && c != 'l') {
					UngetC();
				}
				return NUMBER;
			}
			if(c == '.') {
				do {
					c = GetC();
				} while(c >= '0' && c <= '9');
			}
			if(c == 'e' || c == 'E') {
				c = GetC();
				if(c == '-' || c == '+') {
					c = GetC();
				}
				while(c >= '0' && c <= '9') {
					c = GetC();
				}
			}
			if(c == 'f' || c == 'F') {
				return NUMBER;
			}
			UngetC();
			return NUMBER;

		case '\'':
character:
			c = GetC();
			if(c == '\\') {
				c = GetC();
			}
			c = GetC();
			if(c != '\'') {
				fprintf(stderr, "%s:%ld: error: invalid character\n", f_filename, f_line);
				g_errcnt++;
			}
			return CHARACTER;

		case '"':
string:
			do {
				c = GetC();
				if(c == '\n' || c == '\0') {
					fprintf(stderr, "%s:%ld: error: unterminated string\n", f_filename, f_line);
					g_errcnt++;
					break;
				}
				if(c == '\\') {
					c = GetC();
					if(c == '\n' || c == '\0') {
						fprintf(stderr, "%s:%ld: error: unterminated string\n", f_filename, f_line);
						g_errcnt++;
						break;
					}
					c = '\0';
				}
			} while(c != '"');
			return STRING;

		case 'l':
		case 'L':
			c = GetC();
			if(c == '"') {
				goto string;
			}
			if(c == '\'') {
				goto character;
			}
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
identifier:
			// NOTE: this code allows for :::: and that's fine because the C++
			//	 compiler will catch those.
			do {
				c = GetC();
				if(c == ':') {
					c = GetC();
					if(c != ':') {
						UngetC();
						break;
					}
				}
			} while((c >= 'a' && c <= 'z')
				|| (c >= 'A' && c <= 'Z')
				|| (c >= '0' && c <= '9')
				|| c == '_' || c == ':');
			UngetC();
			return IDENTIFIER;

		case ':':
			c = GetC();
			if(c == ':') {
				// scope operator is part of identifiers here
				goto identifier;
			}
			// colons are used for labels
			UngetC();
			return c;

		// comments are very simply ignored
		case '/':
			n = GetC();
			if(n == '/') {
				do {
					c = GetC();
				} while(c != '\n' && c != '\0');
				break;
			}
			if(n == '*') {
				n = GetC();
				do {
					c = n;
					n = GetC();
				} while(n != '\0' && (c != '*' || n != '/'));
				break;
			}
			UngetC();
			return c;

		default:
			return c;

		}
	}
}


int Lex::GetToken(void)
{
	int t = SubGetToken();
	f_etoken = f_input;

// we ignore \r and \n in the tokens!
// (actually, only \r can be included, but just in case we check both)
#if 0
	while(f_etoken > f_stoken
	  && (f_etoken[-1] == '\r' || f_etoken[-1] == '\n')) {
		--f_etoken;
	}
#endif

#if 0
if(f_stoken != f_etoken) {
printf("Got token [%.*s] type = %d\n", f_etoken - f_stoken, f_stoken, t);
fflush(stdout);
}
#endif

	return t;
}


void Lex::Write(FILE *f)
{
	size_t l = f_etoken - f_stoken;
	size_t w = fwrite(f_stoken, 1, l, f);
	if(l != w) {
		fprintf(stderr, "%s:%ld: error: i/o error while writing to output file", f_filename, f_line);
		g_errcnt++;
	}
#ifdef MO_DEBUG
	else {
		fflush(f);
	}
#endif
}






int get_param(Lex& lex, Param *& p)
{
	const char *s, *e;
	int t, paren;
	p = 0;
	for(;;) {
		do {
			t = lex.GetToken();
		} while(isspace(t) || t == '\n');
		if(t == '\0') {
			return t;
		}
		if(t == ',' || t == ')') {
			if(p == 0) {
				if(t == ',') {
					fprintf(stderr, "%s:%ld: error: ',' not expected here\n", lex.Filename(), lex.Line());
					g_errcnt++;
				}
				return t;
			}
			break;
		}
		if(p == 0) {
			p = new Param;
		}

		if(t == '=') {
			break;
		}
		s = lex.GetStart();
		if(t == '(') {
			p->f_function = true;
			paren = 1;
			do {
				t = lex.GetToken();
				if(t == '(') {
					paren++;
				}
				else if(t == ')') {
					paren--;
				}
			} while(paren != 0 && t != '\0');
		}
		e = lex.GetEnd();

		p->AppendType(s, static_cast<int>(e - s));
	}

// if the type is just 'void' and t is ')' then we don't want it
	if(strcmp(p->f_type, "void") == 0) {
		if(t != ')') {
			fprintf(stderr, "%s:%ld: error: invalid usage of type void in parameter list\n", lex.Filename(), lex.Line());
			g_errcnt++;
			return t;
		}
		delete p;
		p = 0;
		return t;
	}

// compute the name of the parameter
	p->DefineName();

// special case of default values
	if(t == '=') {
		do {
			t = lex.GetToken();
		} while(isspace(t) || t == '\n');
		if(t == '\0') {
			return t;
		}
		if(t == ',') {
			fprintf(stderr, "%s:%ld: error: default value missing for parameter %s\n", lex.Filename(), lex.Line(), p->f_type);
			g_errcnt++;
			return t;
		}
		s = lex.GetStart();
		do {
			e = lex.GetEnd();
			t = lex.GetToken();
		} while(t != ',' && t != ')' && t != '\0');
		if(t == '\0') {
			return t;
		}
		p->SetDefaultValue(s, static_cast<int>(e - s));
	}

	return t;
}



void convert_trans(Lex& lex, const char *class_name, FILE *h, FILE *cpp)
{
	enum {
		DATA_UNDO,
		DATA_DOIT,
		DATA_VARIABLES,
		DATA_HELPERS,
		DATA_max
	};
	int		t, brackets;
	size_t		l;
	const char	*s, *e;
	std::string	trans_name, trans_message, body;
	Param		*params, *last, *next;
	bool		internationalization;

	internationalization = true;

// parse the transaction name and message
	// skip spaces
	do {
		t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t == '\0') {
eof:
		fprintf(stderr, "%s:%ld: error: EOF reached within a transaction declaration\n", lex.Filename(), lex.Line());
		g_errcnt++;
		return;
	}
	if(t != Lex::IDENTIFIER) {
		if(t != '(') {
			fprintf(stderr, "%s:%ld: error: transaction keyword not followed by (\n", lex.Filename(), lex.Line());
			g_errcnt++;
			return;
		}
		do {
			t = lex.GetToken();
		} while(isspace(t) || t == '\n');
		if(t == '\0') {
			goto eof;
		}
		if(t != ')') {
			if(t != Lex::STRING) {
				fprintf(stderr, "%s:%ld: error: transaction parameters can only be static strings\n", lex.Filename(), lex.Line());
				g_errcnt++;
				return;
			}
			trans_name = lex.GetString();
			do {
				t = lex.GetToken();
			} while(isspace(t) || t == '\n');
			if(t == '\0') {
				goto eof;
			}
			if(t == ',') {
				do {
					t = lex.GetToken();
				} while(isspace(t) || t == '\n');
				if(t == '\0') {
					goto eof;
				}
				if(t != Lex::STRING) {
					fprintf(stderr, "%s:%ld: error: transaction parameters can only be static strings\n", lex.Filename(), lex.Line());
					g_errcnt++;
					return;
				}
				trans_message = lex.GetString();
				do {
					t = lex.GetToken();
				} while(isspace(t) || t == '\n');
				if(t == '\0') {
					goto eof;
				}
			}
			if(t != ')') {
				fprintf(stderr, "%s:%ld: error: transaction parameters list is expected to end with ')'\n", lex.Filename(), lex.Line());
				g_errcnt++;
				return;
			}
		}
		do {
			t = lex.GetToken();
		} while(isspace(t) || t == '\n');
		if(t == '\0') {
			goto eof;
		}

		// expecting the function name now
		if(t != Lex::IDENTIFIER) {
			fprintf(stderr, "%s:%ld: error: a function name was expected for this transaction\n", lex.Filename(), lex.Line());
			g_errcnt++;
			return;
		}
	}

// parse the function
	// we got the name of the function (an identifier)
	s = lex.GetStart();
	e = lex.GetEnd();
	l = e - s;
	std::auto_ptr<char> n(new char[l + 1]);
	char *name = n.get();
	memcpy(name, s, l);
	name[l] = '\0';

	do {
		t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t == '\0') {
		goto eof;
	}

	if(t != '(') {
		fprintf(stderr, "%s:%ld: error: transaction function name '%s' not followed by '('\n", lex.Filename(), lex.Line(), name);
		g_errcnt++;
		return;
	}

	// now we read the parameters
	last = params = 0;
	do {
		t = get_param(lex, next);
		if(next != 0) {
			if(last != 0) {
				last->f_next = next;
			}
			if(params == 0) {
				params = next;
			}
			last = next;
		}
	} while(t != ')' && t != '\0');
	if(t == '\0') {
		goto eof;
	}

	// right after the ')' we can have an attribute!
	// the syntax is:
	//	__attribute__ ((<name>, <name>, ...))
	// supported attributes are:
	//	__attribute__ ((i18n))
	//	__attribute__ ((no_i18n))
	do {
		 t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t != Lex::IDENTIFIER) {
		goto no_attributes;
	}
	s = lex.GetStart();
	e = lex.GetEnd();
	l = e - s;
	if(l != 13 || memcmp(s, "__attribute__", 13) != 0) {
		fprintf(stderr, "%s:%ld: error: the keyword __attribute__ or '{' was expected after the transaction function name\n", lex.Filename(), lex.Line());
		g_errcnt++;
		goto skip_attr;
	}
	do {
		 t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t != '(') {
		fprintf(stderr, "%s:%ld: error: the keyword __attribute__ is expected to be followed by two '('\n", lex.Filename(), lex.Line());
		g_errcnt++;
		goto skip_attr;
	}
	do {
		 t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t != '(') {
		fprintf(stderr, "%s:%ld: error: the keyword __attribute__ is expected to be followed by two '('\n", lex.Filename(), lex.Line());
		g_errcnt++;
		goto skip_attr;
	}
	// read all the attributes, they are comma separated
	do {
		do {
			 t = lex.GetToken();
		} while(isspace(t) || t == '\n');
		if(t != Lex::IDENTIFIER) {
			goto empty_attribute;
		}
		s = lex.GetStart();
		e = lex.GetEnd();
		l = e - s;
		if(l == 4 && memcmp(s, "i18n", l) == 0) {
			internationalization = true;
		}
		else if(l == 7 && memcmp(s, "no_i18n", l) == 0) {
			internationalization = false;
		}
		else {
			fprintf(stderr
					, "%s:%ld: error: attribute '%.*s' not supported, only 'i18n' and 'no_i18n' are supported at this time\n"
					, lex.Filename(), lex.Line(), static_cast<int>(l), s
					);
			g_errcnt++;
		}
		do {
			 t = lex.GetToken();
		} while(isspace(t) || t == '\n');
empty_attribute:;
	} while(t == ',');

	if(t != ')') {
		fprintf(stderr, "%s:%ld: error: two ')' were expected to terminate the __attribute__\n", lex.Filename(), lex.Line());
		g_errcnt++;
		goto skip_attr;
	}
	do {
		 t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	if(t != ')') {
		fprintf(stderr, "%s:%ld: error: two ')' were expected to terminate the __attribute__\n", lex.Filename(), lex.Line());
		g_errcnt++;
	}


skip_attr:
	// after the attributes we expect the function body and thus '{'
	do {
		 t = lex.GetToken();
	} while(t != '{' && t != '\0');
no_attributes:
	if(t != '{') {
		fprintf(stderr, "%s:%ld: error: '{' is expected after a transaction function name\n", lex.Filename(), lex.Line());
		g_errcnt++;
		if(t == ';') {
			delete params;
			return;
		}
		// not too sure whether this is a good idea?!
		do {
			 t = lex.GetToken();
		} while(t != '{' && t == '\0');
		if(t == '\0') {
			delete params;
			return;
		}
	}

	// define the code and variables (this is taken as one big block)

	// skip spaces at the start, we don't really need them
	do {
		t = lex.GetToken();
	} while(isspace(t) || t == '\n');
	brackets = 0;
	while(t != '\0') {
		s = lex.GetStart();
		e = lex.GetEnd();
		l = e - s;
		if(t == '}') {
			if(brackets == 0) {
				break;
			}
			--brackets;
		}
		else if(t == '{') {
			++brackets;
		}
		else if(t == Lex::IDENTIFIER) {
			// If it is one of the parameters, then prepend "__f_"
			// since the variables will be renamed as such in the class.
			//
			// Note: Since scoped identifiers include the scope namespace
			//	 we don't have to test that here.
			next = params;
			while(next != 0) {
				if(l == strlen(next->f_name)
				&& memcmp(next->f_name, s, l) == 0) {
					body += "__f_";
					break;
				}
				next = next->f_next;
			}
		}
		body += std::string(s, l);
		t = lex.GetToken();
	}

	if(t != '}') {
		fprintf(stderr, "%s:%ld: error: '{' versus '}' mismatch\n", lex.Filename(), lex.Line());
		g_errcnt++;
	}

// Finally, we got it all, let's convert the result...
	// declare the virtual function
	fprintf(h, "\tvoid\t%s(", name);
	if(params == 0) {
		fprintf(h, "void");
	}
	else {
		next = params;
		while(next != 0) {
			if(next != params) {
				fprintf(h, ", ");
			}
			fprintf(h, "%s", next->f_type);
			if(next->f_default_value != 0) {
				fprintf(h, " = %s", next->f_default_value);
			}
			next = next->f_next;
		}
	}
	fprintf(h, ");\n");


	fprintf(cpp, "class Transaction_%s : public molib::moTransaction\n{\npublic:\n", name);
	fprintf(cpp, "\tTransaction_%s(const molib::moWCString& __name, const molib::moWCString& __message", name);

	if(params != 0) {
		next = params;
		while(next != 0) {
			fprintf(cpp, ", %s", next->f_type);
			// Defaults never used here!
			//if(next->f_default_value != 0) {
			//	fprintf(cpp, " = %s", next->f_default_value);
			//}
			next = next->f_next;
		}
	}
	fprintf(cpp, ")\n\t\t: moTransaction(");
	if(trans_name.size() == 0) {
		fprintf(cpp, "__name");
	}
	else {
		fprintf(cpp, "(__name.IsEmpty() ? ");
		if(internationalization) {
			fprintf(cpp, "gettext(%s)", trans_name.c_str());
		}
		else {
			fprintf(cpp, "%s", trans_name.c_str());
		}
		fprintf(cpp, " : __name)");
	}
	fprintf(cpp, ", ");
	if(trans_message.size() == 0) {
		fprintf(cpp, "__message)");
	}
	else {
		fprintf(cpp, "(__message.IsEmpty() ? ");
		if(internationalization) {
			fprintf(cpp, "gettext(%s)", trans_message.c_str());
		}
		else {
			fprintf(cpp, "%s", trans_message.c_str());
		}
		fprintf(cpp, " : __message))");
	}

	if(params != 0) {
		next = params;
		while(next != 0) {
			fprintf(cpp, ",\n\t\t  __f_%s(%s)", next->f_name, next->f_name);
			next = next->f_next;
		}
	}
	fprintf(cpp, "\n\t\t{\n\t\t}\n\n\t%s\n\n", body.c_str());

	if(params != 0) {
		fprintf(cpp, "private:\n");
		next = params;
		while(next != 0) {
			fprintf(cpp, "\t%s;\n", next->FType());
			next = next->f_next;
		}
	}
	fprintf(cpp, "};\n\n");

	fprintf(cpp, "void %s::%s(", class_name, name);

	if(params == 0) {
		fprintf(cpp, "void");
	}
	else {
		next = params;
		while(next != 0) {
			if(next != params) {
				fprintf(cpp, ", ");
			}
			fprintf(cpp, "%s", next->f_type);
			next = next->f_next;
		}
	}

	fprintf(cpp, ")\n{\n\tf_builder->AddTransaction(new Transaction_%s(f_name, f_message", name);

	next = params;
	while(next != 0) {
		fprintf(cpp, ", %s", next->f_name);
		next = next->f_next;
	}
	fprintf(cpp, "));\n}\n\n");


	delete params;
}




void parse_class(Lex& lex, FILE *h, FILE *cpp)
{
	int		t, brackets;
	size_t		l;
	const char	*s, *e;
	bool		has_transactions;

	has_transactions = false;
	do {
		t = lex.GetToken();
		lex.Write(h);
	} while(isspace(t) || t == '\n');
	if(t != Lex::IDENTIFIER) {
		// is it possible that we don't have an identifier after the keyword class?!
		fprintf(stderr, "%s:%ld: error: expected an identifier after the class keyword\n", lex.Filename(), lex.Line());
		g_errcnt++;
		return;
	}
	// we got the class name!
	s = lex.GetStart();
	e = lex.GetEnd();
	l = e - s;
	std::auto_ptr<char> cn(new char[l + 1]);
	char *class_name = cn.get();
	memcpy(class_name, s, l);
	class_name[l] = '\0';

	brackets = 0;
	for(;;) {
		t = lex.GetToken();
		if(t == '\0') {
			// that's a big problem in the source file!
			return;
		}
		if(t == ';') {
			if(brackets == 0) {
				// in this special case, we don't have a full declaration
				// i.e.:   class Stuff;
				lex.Write(h);
				return;
			}
		}
		else if(t == '{') {
			brackets++;
		}
		else if(t == '}') {
			if(brackets == 0) {
				fprintf(stderr, "%s:%ld: error: could not find { in a class definition\n", lex.Filename(), lex.Line());
				g_errcnt++;
			}
			else {
				brackets--;
			}
			if(brackets == 0) {
				break;
			}
		}
		else if(t == Lex::IDENTIFIER) {
			s = lex.GetStart();
			e = lex.GetEnd();
			if(e - s == 5 && memcmp(s, "class", 5) == 0) {
				// warning: this is a recursive call...
				lex.Write(h);
				parse_class(lex, h, cpp);
			}
			else if(e - s == 11 && memcmp(s, "transaction", 11) == 0) {
				// we found a transaction
				if(!has_transactions) {
					has_transactions = true;
					// special constructor
					fprintf(h, "	%s(molib::moTransactionBuilder& builder, "
						"const molib::moWCString& name = \"\", "
						"const molib::moWCString& message = \"\");\n", class_name);

					fprintf(cpp, "%s::%s(molib::moTransactionBuilder& builder,"
						"const molib::moWCString& name,"
						"const molib::moWCString& message)\n"
						"\t: f_builder(&builder),\n"
						"\t  f_name(name),\n"
						"\t  f_message(message)\n"
						"{\n}\n\n", class_name, class_name);
				}
				convert_trans(lex, class_name, h, cpp);
				continue;
			}
		}
		lex.Write(h);
	}
	// before closing the class, if it includes one or more transactions
	// we want to save the extra variables necessary for that transaction.
	if(has_transactions) {
		fprintf(h, "private:\n"
			"\tmolib::moTransactionBuilderSPtr	f_builder;\n"
			"\tmolib::moWCString		f_name;\n"
			"\tmolib::moWCString		f_message;\n");
	}
	// we don't expect the lexical input to be messed up by
	// the transaction closing the class...
	lex.Write(h);
}


void convert_file(const char *filename, const char *input, FILE *h, FILE *cpp)
{
	int		t, namespaces;
	const char	*s, *e;
	Lex		lex(filename, input);

	// TODO: add better support for namespaces (i.e. count the { and } exactly!)
	namespaces = 0;
	for(;;) {
		t = lex.GetToken();
		if(t == '\0') {
			if(namespaces > 0) {
				while(namespaces > 0) {
					fprintf(cpp, "}");
					--namespaces;
				}
				fprintf(cpp, " // namespaces closing\n");
			}
			break;
		}
		lex.Write(h);
		if(t == Lex::IDENTIFIER) {
			s = lex.GetStart();
			e = lex.GetEnd();
			if(e - s == 5 && memcmp(s, "class", 5) == 0) {
				parse_class(lex, h, cpp);
			}
			else if(e - s == 9 && memcmp(s, "namespace", 9) == 0) {
				lex.Write(cpp);
				// next we expect the name
				t = lex.GetToken();
				if(t != Lex::IDENTIFIER) {
					fprintf(stderr, "%s:%ld: error: the namespace keyword is expected to be followed by a name\n", lex.Filename(), lex.Line());
					g_errcnt++;
				}
				lex.Write(h);
				lex.Write(cpp);
				++namespaces;
			}
		}
	}
}



void remove_cr(char *input)
{
	char *d;

	d = input;
	while(*input != '\0') {
		if(*input == '\r') {
			if(input[1] == '\n') {
				input++;
			}
			else {
				*input = '\n';
			}
		}
		*d++ = *input++;
	}
	*d = '\0';
}


void parse(const char *filename)
{
	FILE		*f, *h, *cpp;
	const char	*ext, *basename;
	char		*input;
	size_t		len;

/* make sure the extension is .async */
	ext = strrchr(filename, '.');
	if(ext == 0 || strcmp(".trans", ext) != 0) {
		return;
	}

/* open the input file */
	f = fopen(filename, "rb");
	if(f == 0) {
		fprintf(stderr, "%s:0: error: cannot open file\n", filename);
		return;
	}

/* open the output files */
	basename = strrchr(filename, '/');
	if(basename == 0) {
		basename = strrchr(filename, '\\');
		if(basename == 0) {
			basename = filename;
		}
		else {
			basename++;
		}
	}
	else {
		basename++;
	}
	len = strlen(basename) - 6;	// strlen(".trans") == 6
	h = open_output(basename, static_cast<int>(len), ".h");
	cpp = open_output(basename, static_cast<int>(len), ".c++");

	if(h == 0 || cpp == 0) {
		if(h != 0) {
			fclose(h);
		}
		if(cpp != 0) {
			fclose(cpp);
		}
		fclose(f);
		return;
	}

	input = read_input(filename, f);

	if(input != 0) {
		// mo_transaction.h needs to be included from within the .trans file!
		//fprintf(h, "#include <mo_transaction.h>\n");

		// auto-include the header
		fprintf(cpp, "#include \"%.*s.h\"\n", static_cast<int>(len), basename);

		remove_cr(input);
		convert_file(filename, input, h, cpp);
		delete [] input;

		// Need extra newline at end of file to keep compiler from complaining.
		fprintf(h, "\n");
	}

	fclose(f);
	fclose(h);
	fclose(cpp);
}




void usage(const char *argv0)
{
	fprintf(stderr, "Usage: %s [-opts] file ...\n", argv0);
	fprintf(stderr, "where -opts is one or more of the following:\n");
	fprintf(stderr, "  -f or --force          replace the output even if it is a user file\n");
	fprintf(stderr, "  -h or --help           print out this usage screen\n");
	fprintf(stderr, "  -o or --output <path>  a path where to save the output files (default: .)\n");
	exit(1);
}

int main(int argc, const char *argv[])
{
	int		i;
	size_t		j, max;
	bool		filenames_only;

	filenames_only = 0;

	i = 1;
	for(i = 1; i < argc; ++i) {
		if(argv[i][0] == '-' && !filenames_only) {
			if(argv[i][1] == '-') {
				// long options
				if(argv[i][2] == '0') {
					filenames_only = 1;
				}
				else if(strcmp(argv[i] + 2, "help") == 0) {
					usage(argv[0]);
					/*NOTREACHED*/
				}
				else if(strcmp(argv[i] + 2, "force") == 0) {
					g_force = true;
				}
				else if(strcmp(argv[i] + 2, "output") == 0) {
					i++;
					if(i >= argc) {
						fprintf(stderr, "<no file>:0: error: expected a path after --output\n");
						usage(argv[0]);
						/*NOTREACHED*/
					}
					setoutput(argv[i]);
				}
				else {
					fprintf(stderr, "<no file>:0: error: unknown option '%s'\n", argv[i]);
					usage(argv[0]);
					/*NOTREACHED*/
				}
			}
			else {
				max = strlen(argv[i]);
				for(j = 1; j < max; ++j) {
					switch(argv[i][j]) {
					case 'f':
						g_force = true;
						break;

					default:
						fprintf(stderr, "<no file>:0: error: unknown option '-%c'\n", argv[i][j]);
					case 'h':
						usage(argv[0]);
						/*NOTREACHED*/

					case 'o':
						/* hmmm 1 */
						i++;
						if(i >= argc) {
							fprintf(stderr, "<no file>:0: error: expected a path after -o\n");
							usage(argv[0]);
							/*NOTREACHED*/
						}
						setoutput(argv[i]);
						/* hmmm 2 */
						j = max;
						break;

					}
				}
			}
		}
		else {
			parse(argv[i]);
		}
	}

	return g_errcnt > 0 ? 1 : 0;
}



